// generated by tools
// AHeadLib.Net
// https://github.com/bodong1987/AHeadLib.Net
// Powered by bodong

#include "MiniTools.h"
#include <algorithm>
#include <cassert>

BOOL ReplaceMemory(void* dest, const void* source, int length)
{
    void* TargetAddress = dest;

    DWORD oldProtect;
    if (!VirtualProtect(TargetAddress, length, PAGE_EXECUTE_READWRITE, &oldProtect))
    {
        AHEAD_LIB_SHOW_MESSAGE_BOX(nullptr, TEXT("Failed to obtain write permission for target address"), TEXT("Error"), 0);

        return FALSE;
    }

    memcpy(TargetAddress, source, length);

    if (!VirtualProtect(TargetAddress, length, oldProtect, &oldProtect))
    {
        // error
        AHEAD_LIB_SHOW_MESSAGE_BOX(nullptr, TEXT("Failed write code."), TEXT("Error"), 0);
        return FALSE;
    }

    // clear
    FlushInstructionCache(GetCurrentProcess(), TargetAddress, length);

    return TRUE;
}

BOOL FindModuleSection(HMODULE module, const char* segmentName, void** outSectionStart, LONGLONG* outSize)
{
    *outSectionStart = nullptr;
    *outSize = 0;

    MODULEINFO module_info;
    GetModuleInformation(GetCurrentProcess(), module, &module_info, sizeof(module_info));
    void* Address = module_info.lpBaseOfDll;

    // get module pe
    const auto dosHeader = static_cast<PIMAGE_DOS_HEADER>(Address);
    auto ntHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(static_cast<BYTE*>(Address) + dosHeader->e_lfanew);

    auto sectionHeader = IMAGE_FIRST_SECTION(ntHeaders);
    for (int i = 0; i < ntHeaders->FileHeader.NumberOfSections; i++, sectionHeader++)
    {
        const LONGLONG sectionBase = reinterpret_cast<LONGLONG>(Address) + sectionHeader->VirtualAddress;
        const LONGLONG sectionSize = sectionHeader->Misc.VirtualSize;

        if (strcmp(reinterpret_cast<char*>(sectionHeader->Name), segmentName) == 0)
        {
            *outSectionStart = reinterpret_cast<void*>(sectionBase); // NOLINT(performance-no-int-to-ptr)
            *outSize = sectionSize;

            return TRUE;
        }        
    }

    return FALSE;
}

void* SearchInSection(HMODULE module, const char* segmentName, const void* signature, int length)
{
    void* SectionStart = nullptr;
    LONGLONG SectionSize = 0;

    if (!FindModuleSection(module, segmentName, &SectionStart, &SectionSize))
    {
        return nullptr;
    }

    return SearchInMemory(SectionStart, static_cast<BYTE*>(SectionStart) + SectionSize, signature, length);
}

void* SearchInMemory(const void* startPos, const void* endPos, const void* signature, int length)
{
    const BYTE* position = std::search(
        const_cast<BYTE*>(static_cast<const BYTE*>(startPos)),
        const_cast<BYTE*>(static_cast<const BYTE*>(endPos)),
        static_cast<const BYTE*>(signature),
        static_cast<const BYTE*>(signature) + length
        );  

    if (position == nullptr || position == const_cast<BYTE*>(static_cast<const BYTE*>(endPos)))
    {
        return nullptr;
    }   

    return const_cast<BYTE*>(position);
}

BOOL PatchMemory(HMODULE module, const char* segmentName, const void* signature, const void* newBytes, int length)
{
    void* pos = SearchInSection(module, segmentName, signature, length);

    assert(pos != nullptr);

    if (pos == nullptr)
    {
        return FALSE;
    }

    ReplaceMemory(pos, newBytes, length);

    return TRUE;
}

BOOL PatchMultipleMemories(HMODULE module, const char* segmentName, const void** signaturePtr, const void** newBytesPtr, const int* lengthPtr, int count)
{
    void* SectionStart = nullptr;
    LONGLONG SectionSize = 0;

    if (!FindModuleSection(module, segmentName, &SectionStart, &SectionSize))
    {
        return FALSE;
    }

    for (int i = 0; i < count; ++i)
    {
        const void* signature = signaturePtr[i];
        const void* newBytes = newBytesPtr[i];
        const int length = lengthPtr[i];

        void* position = SearchInMemory(SectionStart, static_cast<BYTE*>(SectionStart) + SectionSize, signature, length);

        if (!ReplaceMemory(position, newBytes, length))
        {
            return FALSE;
        }
    }

    return TRUE;
}
